快速排序：
通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，
然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

最坏情况：时间复杂度为n^2 ; 最好情况：时间复杂度为n*log2(n)  ;  平均情况：时间复杂度为：n*log2(n)


冒泡排序：
最坏情况：时间复杂度为n^2 ; 最好情况：时间复杂度为n ; 平均情况：时间复杂度为：n^2


堆排序：// http://blog.csdn.net/kimylrong/article/details/17150475
利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种

堆实质上是满足如下性质的完全二叉树：
树中任一非叶子结点的关键字均不大于（或不小于）其左右孩子（若存在）结点的关键字

堆排序步骤：
1，构建最大堆。
2，选择顶，并与第0位置元素交换
3，由于步骤2的的交换可能破环了最大堆的性质，第0不再是最大元素，需要调用maxHeap调整堆(沉降法)，如果需要重复步骤2

最坏情况：时间复杂度为n*log(n)


并归排序： // http://www.cnblogs.com/jingmoxukong/p/4308823.html
将待排序序列R[0...n-1]看成是n个长度为1的有序序列，将相邻的有序表成对归并，得到n/2个长度为2的有序表；
将这些有序序列再次归并，得到n/4个长度为4的有序序列；如此反复进行下去，最后得到一个长度为n的有序序列

最坏情况：n*log(n)



【归并排序和堆排序、快速排序的比较】
若从空间复杂度来考虑：首选堆排序，其次是快速排序，最后是归并排序。

若从稳定性来考虑，应选取归并排序，因为堆排序和快速排序都是不稳定的。

若从平均情况下的排序速度考虑，应该选择快速排序。 
