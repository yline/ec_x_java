package com.test;

import com.test.base.Solution;

/**
 * 
 * @author YLine
 *
 * 2018年7月26日 下午3:41:15
 */
public class SolutionC implements Solution
{
    
    @Override
    public boolean isMatch(String s, String p)
    {
        if (s == null || p == null)
            return false;
        
        // match[i][j] = Can first i chars of s pattern match against first j chars of p
        boolean[][] match = new boolean[s.length() + 1][p.length() + 1];
        match[0][0] = true;
        
        char[] sArr = s.toCharArray();
        char[] pArr = p.toCharArray();
        
        // Testing out if first j chars of p can match against an empty string
        for (int j = 1; j <= p.length(); j++)
        {
            if (pArr[j - 1] == '*')
            {
                match[0][j] = match[0][j - 2];
            }
        }
        
        for (int i = 1; i <= s.length(); i++)
        {
            for (int j = 1; j <= p.length(); j++)
            {
                char sCh = sArr[i - 1];
                char pCh = pArr[j - 1];
                
                if (sCh == pCh || pCh == '.')
                {
                    match[i][j] = match[i - 1][j - 1];
                }
                else if (pCh == '*')
                {
                    char pPrevCh = pArr[j - 2]; 
                    match[i][j] = (sCh == pPrevCh || pPrevCh == '.') 
                        && match[i - 1][j] || match[i][j - 1] || match[i][j - 2];
                    
                    // Cases:
                    // - Treat as if there are more generated by Kleene closure
                    //       - Requires that character before * either matches or is .
                    // - Treat as if last one in Kleene closure
                    // - Treat as if none in Kleene closure
                }
            }
        }
        
        return match[s.length()][p.length()];
    }
    
}
