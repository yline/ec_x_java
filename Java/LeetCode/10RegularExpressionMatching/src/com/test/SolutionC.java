package com.test;

import com.test.base.Solution;

/**
 * 
 * @author YLine
 *
 * 2018年7月26日 下午3:41:15
 */
public class SolutionC implements Solution
{
    
    @Override
    public boolean isMatch(String s, String p)
    {
        if (s == null || p == null)
            return false;
        
        // match[i][j] = Can first i chars of s pattern match against first j chars of p
        boolean[][] match = new boolean[s.length() + 1][p.length() + 1];
        match[0][0] = true;
        
        char[] sArr = s.toCharArray();
        char[] pArr = p.toCharArray();
        
        // Testing out if first j chars of p can match against an empty string
        for (int j = 1; j <= p.length(); j++)
        {
            if (pArr[j - 1] == '*')
            {
                match[0][j] = match[0][j - 2];
            }
        }
        
        for (int i = 1; i <= s.length(); i++)
        {
            for (int j = 1; j <= p.length(); j++)
            {
                char sCh = sArr[i - 1];
                char pCh = pArr[j - 1];
                
                if (sCh == pCh || pCh == '.')
                {
                    match[i][j] = match[i - 1][j - 1];
                }
                else if (pCh == '*')
                {
                    char pPrevCh = pArr[j - 2];
                    match[i][j] =
                        (sCh == pPrevCh || pPrevCh == '.') && match[i - 1][j] || match[i][j - 1] || match[i][j - 2];
                    
                    // Cases:
                    // - Treat as if there are more generated by Kleene closure
                    //       - Requires that character before * either matches or is .
                    // - Treat as if last one in Kleene closure
                    // - Treat as if none in Kleene closure
                }
            }
        }
        
        print(match, s, p);
        
        return match[s.length()][p.length()];
    }
    
    private void print(boolean[][] match, String s, String p)
    {
        StringBuilder stringBuilder = new StringBuilder();
        
        // 打印第一行
        stringBuilder.append("   ");
        stringBuilder.append("   ");
        for (int i = 0; i <= p.length(); i++)
        {
            stringBuilder.append(" ");
            stringBuilder.append(i);
            stringBuilder.append(" ");
        }
        stringBuilder.append('\n');
        
        // 打印第二行
        stringBuilder.append("   ");
        stringBuilder.append("   ");
        stringBuilder.append(" @ ");
        for (int i = 0; i < p.length(); i++)
        {
            stringBuilder.append(" ");
            stringBuilder.append(p.charAt(i));
            stringBuilder.append(" ");
        }
        stringBuilder.append('\n');
        
        // 循环打印表格
        for (int i = 0; i < match.length; i++)
        {
            if (i == 0)
            {
                stringBuilder.append(" 0 ");
                stringBuilder.append(" @ ");
            }
            else
            {
                stringBuilder.append(" ");
                stringBuilder.append(i);
                stringBuilder.append(" ");
                
                stringBuilder.append(" ");
                stringBuilder.append(s.charAt(i - 1));
                stringBuilder.append(" ");
            }
            
            for (int j = 0; j < match[i].length; j++)
            {
                stringBuilder.append(match[i][j] ? " √ " : " × ");
            }
            stringBuilder.append('\n');
        }
        
        System.out.println(stringBuilder.toString());
    }
}
